<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Snake Spelling</title>
  <link rel="stylesheet" href="../styles.css">
  <style>
    .drawer {
      position: fixed;
      top: 0;
      right: -230px;
      width: 240px;
      height: 100%;
      background-color: #f9fafb;
      box-shadow: -2px 0 8px rgba(0,0,0,0.1);
      transition: right 0.3s ease-in-out;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .drawer.open {
      right: 0;
    }
    .drawer-toggle {
      position: absolute;
      top: 50%;
      right: 100%;
      transform: translateY(-50%);
      z-index: 1001;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 1rem 0.5rem;
      border-radius: 8px 0 0 8px;
      font-weight: bold;
      border-right-width: 0;
    }
    .drawer-toggle::before {
      content: '\25c0';
      display: inline-block;
      margin-bottom: 0.5em;
    }
    .drawer.open .drawer-toggle::before {
      content: '\25b6';
    }
    .drawer-content .icon {
      width: 100%;
      justify-content: flex-start;
    }
    .drawer-content {
      padding: 1rem;
      flex-grow: 1;
      overflow-y: auto;
    }
    .drawer-footer {
      padding: 1rem;
      border-top: 1px solid var(--border);
    }
    @media print {
      .drawer, .toolbar {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="settingsDrawer" class="drawer">
    <button id="drawerToggleBtn" class="icon drawer-toggle">Menu</button>
    <div class="drawer-content">
      <h3>Game Options</h3>
      <div style="margin-bottom:18px;">
        <label style="display:flex;align-items:center;gap:8px;font-weight:bold;">Snake Speed:
          <input type="range" id="speedSlider" min="3" max="10" value="5" style="flex:1;">
        </label>
      </div>
      <div>
        <label style="display:flex;align-items:center;gap:8px;font-weight:bold;">
          <input type="checkbox" id="edgeToggle" checked style="width:18px;height:18px;">
          Letters on edge
        </label>
      </div>
    </div>
    <div class="drawer-footer"><a href="../index.html"><button class="icon" style="width: 100%; justify-content: flex-start;">üè† Home</button></a></div>
  </div>
<div class="container" style="display: flex; flex-direction: row; gap: 32px; align-items: flex-start;">
  <div style="flex: 1 1 auto; min-width: 0; display: flex; flex-direction: column;">
    <div class="toolbar" style="display: flex; align-items: center; justify-content: flex-start; gap: 18px;">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge" id="wordBadge">Word: <span id="targetWord">---</span></div>
      <div class="badge">Collected: <span id="progress">0</span></div>
    </div>
    <div style="display: flex; flex-direction: row; align-items: flex-start; gap: 32px;">
      <div style="position:relative;">
        <button id="pauseBtn" class="icon" style="position:absolute;top:-48px;right:0;z-index:3;">‚è∏Ô∏è Pause</button>
        <canvas id="snakeCanvas" width="480" height="480"></canvas>
        <div id="startOverlay" style="position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.08);z-index:2;">
          <div class="card"><div class="card-body"><h2>Press any button to begin</h2></div></div>
        </div>
      </div>
      <div id="sidebarPanel" style="min-width:220px;max-width:300px;margin-top:0;align-self:flex-start;">
        <div style="font-weight:bold;font-size:1.2em;margin-bottom:10px;">Words to Complete</div>
        <ol id="wordList" style="padding-left:18px;margin:0;display:grid;gap:6px;"></ol>
      </div>
    </div>
    <div class="small">Use arrow keys or WASD. Collect the letters in the correct order. Hitting walls or yourself ends the run.</div>
  </div>
</div>
<script type="module">
  // Drawer logic
  const drawerToggleBtn = document.getElementById("drawerToggleBtn");
  const settingsDrawer = document.getElementById("settingsDrawer");
  const pauseBtnDrawer = document.getElementById("pauseBtnDrawer");
  const targetWordDrawer = document.getElementById("targetWordDrawer");
  const progressDrawer = document.getElementById("progressDrawer");
  const scoreDrawer = document.getElementById("scoreDrawer");

  if (drawerToggleBtn && settingsDrawer) {
    drawerToggleBtn.addEventListener('click', () => {
      settingsDrawer.classList.toggle('open');
    });
  }

  // Forward drawer pause to main pause
  if (pauseBtnDrawer) pauseBtnDrawer.onclick = () => document.getElementById('pauseBtn').click();

  // Sync drawer stats with main stats
  function syncDrawerStats() {
    if (targetWordDrawer) targetWordDrawer.textContent = document.getElementById('targetWord').textContent;
    if (progressDrawer) progressDrawer.textContent = document.getElementById('progress').textContent;
    if (scoreDrawer) scoreDrawer.textContent = document.getElementById('score').textContent;
  }
  import { loadConfig, normalizeWord } from "./app.js";

  const cfg = loadConfig() || { words: ["SAMPLE", "WORDS", "HERE"], options: {} };
  const savedSettings = (() => {
    try {
      const raw = localStorage.getItem("wordGamesSettings");
      return raw ? JSON.parse(raw) : null;
    } catch (error) {
      console.warn("Could not parse saved settings for snake.", error);
      return null;
    }
  })();

  const snakeSettings = savedSettings?.games?.snake || {};
  let speedSetting = 5;
  const wallsEnabled = Object.prototype.hasOwnProperty.call(snakeSettings, "walls") ? Boolean(snakeSettings.walls) : true;
  let baseInterval = Math.max(110, 260 - speedSetting * 18);

  let words = Array.from(new Set(cfg.words.map(normalizeWord))).filter(Boolean);
  let wordQueue = words.slice();
  const canvas = document.getElementById("snakeCanvas");
  const ctx = canvas.getContext("2d");
  const wordListEl = document.getElementById("wordList");
  const size = 16;
  const cell = canvas.width / size;

  let snake;
  let dir;
  let nextDir;
  let food;
  let target;
  let letterIndex;
  let score = 0;
  let alive = true;
  let tickHandle = null;

  const targetEl = document.getElementById("targetWord");
  const progEl = document.getElementById("progress");
  const scoreEl = document.getElementById("score");

  function pickTarget() {
    if (wordQueue.length === 0) {
      target = null;
      renderTargetWord();
      renderWordList();
      return;
    }
    target = wordQueue[0];
    letterIndex = 0;
    renderTargetWord();
    renderWordList();
    if (progEl) {
      progEl.textContent = "0";
    }
  }

  function renderWordList() {
    if (!wordListEl) return;
    wordListEl.innerHTML = "";
    wordQueue.forEach((w, i) => {
      const li = document.createElement("li");
      li.textContent = w;
      if (i === 0) {
        li.style.fontWeight = "bold";
        li.style.color = "#1e40af";
      }
      wordListEl.appendChild(li);
    });
    if (wordQueue.length === 0) {
      const li = document.createElement("li");
      li.textContent = "All words complete!";
      li.style.color = "#10b981";
      wordListEl.appendChild(li);
    }
  }

  function placeFood() {
    const edgeAllowed = document.getElementById('edgeToggle')?.checked ?? true;
    while (true) {
      let x = Math.floor(Math.random() * size);
      let y = Math.floor(Math.random() * size);
      if (!edgeAllowed) {
        if (x === 0 || y === 0 || x === size - 1 || y === size - 1) continue;
      }
      if (!snake.some(segment => segment.x === x && segment.y === y)) {
        food = { x, y, letter: target[letterIndex] };
        return;
      }
    }
  }
  // Speed slider logic
  const speedSlider = document.getElementById('speedSlider');
  if (speedSlider) {
    speedSlider.addEventListener('input', (e) => {
      speedSetting = Number(speedSlider.value);
      baseInterval = Math.max(110, 260 - speedSetting * 18);
    });
  }

  // Edge toggle logic
  const edgeToggle = document.getElementById('edgeToggle');
  if (edgeToggle) {
    edgeToggle.addEventListener('change', () => {
      placeFood();
    });
  }

  function renderTargetWord() {
    if (!targetEl) {
      return;
    }
    if (!target) {
      targetEl.textContent = "";
      return;
    }
    targetEl.innerHTML = "";
    const fragment = document.createDocumentFragment();
    const letters = target.split("");
    letters.forEach((char, idx) => {
      const span = document.createElement("span");
      span.classList.add("word-letter");
      if (idx < letterIndex) {
        span.classList.add("word-letter--done");
      } else if (idx === letterIndex) {
        span.classList.add("word-letter--current");
      }
      span.textContent = char;
      fragment.appendChild(span);
    });
    targetEl.appendChild(fragment);
    // Also update wordBadge to show highlighted letter
    const wordBadge = document.getElementById('wordBadge');
    if (wordBadge) {
      wordBadge.innerHTML = 'Word: ';
      letters.forEach((char, idx) => {
        const span = document.createElement('span');
        span.classList.add('word-letter');
        if (idx < letterIndex) {
          span.classList.add('word-letter--done');
        } else if (idx === letterIndex) {
          span.classList.add('word-letter--current');
        }
        span.textContent = char;
        wordBadge.appendChild(span);
      });
    }
  }

  function syncSnakeLengthWithScore() {
    const desiredLength = Math.max(1, score + 1);
    if (snake.length > desiredLength) {
      snake.splice(desiredLength);
      return;
    }
    if (snake.length < desiredLength) {
      const tail = snake[snake.length - 1] || snake[0] || { x: Math.floor(size / 2), y: Math.floor(size / 2) };
      while (snake.length < desiredLength) {
        snake.push({ x: tail.x, y: tail.y });
      }
    }
  }

  function reset() {
    words = Array.from(new Set(cfg.words.map(normalizeWord))).filter(Boolean);
    wordQueue = words.slice();
    snake = [{ x: Math.floor(size / 2), y: Math.floor(size / 2) }];
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };
    alive = true;
    score = 0;
    scoreEl.textContent = "0";
    pickTarget();
    placeFood();
    draw();
  }

  let paused = false;
  function scheduleTick() {
    if (!alive || paused) {
      return;
    }
    const interval = Math.max(80, baseInterval - score * 4);
    tickHandle = setTimeout(tick, interval);
  }

  function tick() {
    if (!alive || paused) {
      return;
    }
    dir = nextDir;
    let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    if (wallsEnabled) {
      if (head.x < 0 || head.y < 0 || head.x >= size || head.y >= size) {
        gameOver();
        return;
      }
    } else {
      if (head.x < 0) head.x = size - 1;
      else if (head.x >= size) head.x = 0;
      if (head.y < 0) head.y = size - 1;
      else if (head.y >= size) head.y = 0;
    }

    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);
    if (head.x === food.x && head.y === food.y) {
      letterIndex++;
      if (progEl) {
        progEl.textContent = String(letterIndex);
      }
      renderTargetWord();
      if (target && letterIndex >= target.length) {
        score++;
        scoreEl.textContent = String(score);
        // Remove completed word from queue
        if (wordQueue.length > 0) {
          wordQueue.shift();
        }
        syncSnakeLengthWithScore();
        pickTarget();
      }
      placeFood();
    } else {
      snake.pop();
    }

    draw();
    scheduleTick();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "#e5e7eb";
    for (let i = 0; i <= size; i++) {
      ctx.beginPath();
      ctx.moveTo(0, i * cell);
      ctx.lineTo(canvas.width, i * cell);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(i * cell, 0);
      ctx.lineTo(i * cell, canvas.height);
      ctx.stroke();
    }
    ctx.fillStyle = "#2563eb";
    snake.forEach(segment => {
      ctx.fillRect(segment.x * cell + 2, segment.y * cell + 2, cell - 4, cell - 4);
    });
    ctx.fillStyle = "#0f172a";
    ctx.font = "bold " + cell * 0.6 + "px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(food.letter, food.x * cell + cell / 2, food.y * cell + cell / 2);
  }

  function gameOver() {
    alive = false;
    if (tickHandle) {
      clearTimeout(tickHandle);
      tickHandle = null;
    }
    ctx.fillStyle = "rgba(0,0,0,.08)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#111827";
    ctx.font = "bold 28px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("Game Over - Score: " + score, canvas.width / 2, canvas.height / 2);
  }

  window.addEventListener("keydown", event => {
    const key = event.key.toLowerCase();
    if ((key === "arrowup" || key === "w") && dir.y !== 1) nextDir = { x: 0, y: -1 };
    else if ((key === "arrowdown" || key === "s") && dir.y !== -1) nextDir = { x: 0, y: 1 };
    else if ((key === "arrowleft" || key === "a") && dir.x !== 1) nextDir = { x: -1, y: 0 };
    else if ((key === "arrowright" || key === "d") && dir.x !== -1) nextDir = { x: 1, y: 0 };
  });

  // Show start overlay and wait for any key/button to begin
  const startOverlay = document.getElementById("startOverlay");
  const pauseBtn = document.getElementById("pauseBtn");
  function startGame() {
    if (startOverlay) startOverlay.style.display = "none";
    reset();
    scheduleTick();
    window.removeEventListener("keydown", startGameListener);
    window.removeEventListener("mousedown", startGameListener);
    window.removeEventListener("touchstart", startGameListener);
    if (pauseBtn) pauseBtn.disabled = false;
  }
  function startGameListener() {
    startGame();
  }
  window.addEventListener("keydown", startGameListener);
  window.addEventListener("mousedown", startGameListener);
  window.addEventListener("touchstart", startGameListener);

  // Pause button logic
  if (pauseBtn) {
    pauseBtn.disabled = true;
    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
      if (!paused) scheduleTick();
    });
  }
</script>
</body>
</html>










