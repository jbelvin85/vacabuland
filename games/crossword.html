<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crossword</title>
  <link rel="stylesheet" href="../styles.css">
  <style>
    .drawer {
      position: fixed;
      top: 0;
      right: -230px; /* Leave about 10px of the drawer visible */
      width: 240px;
      height: 100%;
      background-color: #f9fafb;
      box-shadow: -2px 0 8px rgba(0,0,0,0.1);
      transition: right 0.3s ease-in-out;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .drawer.open {
      right: 0;
    }
    .drawer-toggle {
      position: absolute;
      top: 50%;
      right: 100%; /* Position it just to the left of the drawer */
      transform: translateY(-50%);
      z-index: 1001;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      padding: 1rem 0.5rem;
      border-radius: 8px 0 0 8px;
      font-weight: bold; /* Make the menu text bold */
      border-right-width: 0;
    }
    .drawer-toggle::before {
      content: '◀';
      display: inline-block;
      margin-bottom: 0.5em;
    }
    .drawer.open .drawer-toggle::before {
      content: '▶';
    }
    .drawer-content .icon {
      width: 100%;
      justify-content: flex-start;
    }
    .drawer-content {
      padding: 1rem;
      flex-grow: 1; /* Allow this section to grow and fill available space */
      overflow-y: auto; /* Add scroll if content overflows */
    }
    .drawer-footer {
      padding: 1rem;
      border-top: 1px solid var(--border);
    }
    @media print {
      /* Hide the settings drawer and toolbar when printing */
      .drawer, .toolbar {
        display: none;
      }
    }

  .cross-cell.black {
    background: transparent;
    border: none;
    color: transparent;
    box-shadow: none;
  }
  .correct-word {
    outline: 2.5px solid var(--success) !important;
    outline-offset: -2px;
  }
  </style>
</head>
<body>
<div id="settingsDrawer" class="drawer">
  <button id="drawerToggleBtn" class="icon drawer-toggle">Menu</button>
  <div class="drawer-content">
    <h3>Game Controls</h3>
    <button id="regenBtn" class="icon">Regenerate</button>
    <button id="toggleSolutionBtn" class="icon">Show Solution</button>
    <button id="hintBtn" class="icon">First-Letter Hint</button>
    <span class="badge" id="hintStatus">Hints left: 0</span>
    <button id="printBtn" class="icon">Print</button>
  </div>
  <div class="drawer-footer"><a href="../index.html"><button class="icon" style="width: 100%; justify-content: flex-start;">&#127968; Home</button></a></div>
</div>

<div class="container">
  <div class="row">
    <div class="card"><div class="card-body"><div id="crossGrid" class="grid"></div></div></div>
  </div>
  <div class="row">
    <div class="card clues-wide"><div class="card-body">
      <h4 style="margin-bottom:4px;display:inline-block;">Across</h4>
      <ol id="cluesAcross" style="margin-bottom:10px;"></ol>
      <h4 style="margin-bottom:4px;display:inline-block;">Down</h4>
      <ol id="cluesDown"></ol>
    </div></div>
  </div>
</div>
<script type="module">
import { loadConfig } from "./app.js";
import { generateCrossword } from "./crossword.js";

let cfg = loadConfig();
if (!cfg || !Array.isArray(cfg.words) || cfg.words.length === 0) {
  document.body.innerHTML = '<div class="container"><h2>No word list selected!</h2><p>Please return to the home page and select or create a word list before launching the game.</p><div style="margin-top:2em"><a href="../index.html"><button class="icon">Home</button></a></div></div>';
  throw new Error("No word list selected.");
}

const savedSettings = (() => {
  try {
    const raw = localStorage.getItem("wordGamesSettings");
    return raw ? JSON.parse(raw) : null;
  } catch (error) {
    console.warn("Could not parse saved settings for crossword.", error);
    return null;
  }
})();

const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
const crosswordSettings = savedSettings?.games?.crossword || {};
const defaultGridSize = cfg?.options?.size ?? 15;
const gridSize = clamp(Number(crosswordSettings.gridSize) || defaultGridSize, 10, 25);
const cellSize = clamp(Number(crosswordSettings.cellSize) || 36, 28, 48);
const showNumbers = crosswordSettings.showNumbers !== false;
const hoverHighlight = crosswordSettings.hoverHighlight !== false;
const hintAllowance = clamp(Number(crosswordSettings.hintAllowance) || 0, 0, 10);

let words = Array.isArray(cfg?.words) && cfg.words.length ? cfg.words : ["FUN", "SAMPLE", "WORDS", "HERE"];
words = Array.from(new Set(words.map(item => String(item.word || item || "").replace(/[^A-Za-z]/g, "").toUpperCase()).filter(Boolean)));
words = words.filter(word => word.length <= gridSize);

const grid = document.getElementById("crossGrid");
const regenBtn = document.getElementById("regenBtn");
const printBtn = document.getElementById("printBtn");
const toggleBtn = document.getElementById("toggleSolutionBtn");
const hintBtn = document.getElementById("hintBtn");
const drawerToggleBtn = document.getElementById("drawerToggleBtn");
const settingsDrawer = document.getElementById("settingsDrawer");
const hintStatus = document.getElementById("hintStatus");
const cluesAcross = document.getElementById("cluesAcross");
const cluesDown = document.getElementById("cluesDown");

const defaultToggleLabel = toggleBtn ? toggleBtn.textContent : "Show Solution";
const hideToggleLabel = "Hide Solution";

let showSolution = false;
let crosswordData = null;
let hintsRemaining = hintAllowance;
const revealedCells = new Set();

function updateGridClasses() {
  if (!grid) return;
  if (hoverHighlight) grid.classList.add("hover-highlight");
  else grid.classList.remove("hover-highlight");
}

function updateHintUI() {
  if (!hintBtn || !hintStatus) return;
  if (hintAllowance <= 0) {
    hintBtn.style.display = "none";
    hintStatus.style.display = "none";
    return;
  }
  hintBtn.style.display = "";
  hintStatus.style.display = "";
  hintStatus.textContent = `Hints left: ${Math.max(hintsRemaining, 0)}`;
  hintBtn.disabled = hintsRemaining <= 0 || showSolution;
}

function renderClues() {
  if (!cluesAcross || !cluesDown) return;
  cluesAcross.innerHTML = "";
  cluesDown.innerHTML = "";
  if (!crosswordData || !Array.isArray(crosswordData.placements)) return;
  // Sort placements by number, then by direction (across before down for same number)
  const sortedPlacements = [...crosswordData.placements].sort((a, b) => {
    if (a.number !== b.number) return a.number - b.number;
    if (a.direction === b.direction) return 0;
    return a.direction === "across" ? -1 : 1;
  });
  for (const p of sortedPlacements) {
    const li = document.createElement("li");
    li.textContent = p.clue;
    li.value = p.number;
    const targetList = p.direction === "across" ? cluesAcross : cluesDown;
    targetList.appendChild(li);
  }
}

function renderGrid() {
  if (!grid) return;
  grid.innerHTML = "";
  grid.style.setProperty("--cell-size", `${cellSize}px`);
  if (!crosswordData || !Array.isArray(crosswordData.grid)) {
    grid.innerHTML = "<div class=\"small\">No words available for this crossword.</div>";
    return;
  }
  const size = crosswordData.grid.length;
  grid.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
  const numbers = crosswordData.numbers || [];
  let activePlacement = null;
  let inputCells = [];
  let inputMode = false;
  function clearInputMode() {
    inputMode = false;
    activePlacement = null;
    inputCells.forEach(cell => {
      cell.classList.remove("highlight");
      cell.contentEditable = "false";
      cell.removeAttribute("tabindex");
    });
    inputCells = [];
    document.removeEventListener("keydown", handleGridInputKeydown);
  }
  function handleGridInputKeydown(e) {
    if (!inputMode || !inputCells.length) return;
    let idx = inputCells.findIndex(cell => document.activeElement === cell);
    if (e.key === "ArrowLeft" && idx > 0) {
      inputCells[idx - 1].focus();
      e.preventDefault();
    } else if (e.key === "ArrowRight" && idx < inputCells.length - 1) {
      inputCells[idx + 1].focus();
      e.preventDefault();
    } else if (e.key === "Backspace") {
      if (idx >= 0) {
        if (inputCells[idx].textContent) {
          inputCells[idx].textContent = "";
        } else if (idx > 0) {
          inputCells[idx - 1].focus();
        }
        e.preventDefault();
      }
    } else if (e.key === "Escape") {
      clearInputMode();
      e.preventDefault();
    }
  }
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const index = y * size + x;
      const value = crosswordData.grid[y][x];
      const cell = document.createElement("div");
      cell.className = "cross-cell" + (value === "#" ? " black" : "");
      cell.style.width = `${cellSize}px`;
      cell.style.height = `${cellSize}px`;
      if (value !== "#") {
        cell.dataset.index = String(index);
        cell.dataset.letter = value;
        cell.dataset.x = x;
        cell.dataset.y = y;
        if (showNumbers && numbers[y] && numbers[y][x]) {
          const numEl = document.createElement("span");
          numEl.className = "cell-number";
          numEl.textContent = numbers[y][x];
          cell.appendChild(numEl);
        }
        const letterEl = document.createElement("div");
        letterEl.className = "cell-letter";
        letterEl.textContent = (showSolution || revealedCells.has(index)) ? value : "";
        cell.appendChild(letterEl);
        // Add click handler for numbered cells
        if (numbers[y] && numbers[y][x]) {
          cell.style.cursor = "pointer";
          cell.addEventListener("click", (e) => {
            // Find all placements that start at this cell
            const starts = (crosswordData.placements || []).filter(p => {
              if (!p.cells || !p.cells.length) return false;
              const [px, py] = p.cells[0];
              return px === x && py === y;
            });
            if (!starts.length) return;
            // Prefer across, else down
            const placement = starts.find(p => p.direction === "across") || starts[0];
            if (!placement) return;
            // Clear previous input mode
            clearInputMode();
            inputMode = true;
            activePlacement = placement;
            inputCells = [];
            // Highlight and enable editing for each cell in the word
            for (let i = 0; i < placement.cells.length; i++) {
              const [cx, cy] = placement.cells[i];
              const gridCell = grid.children[cy * size + cx];
              if (!gridCell) continue;
              gridCell.classList.add("highlight");
              gridCell.contentEditable = "true";
              gridCell.setAttribute("tabindex", "0");
              inputCells.push(gridCell);
            }
            // Focus first cell
            if (inputCells.length) inputCells[0].focus();
            // Keyboard navigation
            document.addEventListener("keydown", handleGridInputKeydown);
            // Input handler for each cell
            function checkWordFilledAndValidate() {
              const guess = inputCells.map(cell => {
                // Always use .cell-letter content for validation and display
                const letterEl = cell.querySelector('.cell-letter');
                return letterEl ? (letterEl.textContent || '').toUpperCase() : '';
              }).join("");
              const answer = activePlacement.word;
              if (guess.length === answer.length && !guess.includes("") && !guess.match(/[^A-Z]/)) {
                if (guess === answer) {
                  // Correct: highlight green
                  inputCells.forEach(cell => {
                    cell.classList.add("correct-word");
                    cell.contentEditable = "false";
                  });
                  setTimeout(() => {
                    inputCells.forEach(cell => {
                      cell.classList.remove("highlight");
                      cell.classList.remove("correct-word");
                    });
                    clearInputMode();
                  }, 900);
                } else {
                  // Incorrect: clear all
                  setTimeout(() => {
                    inputCells.forEach(cell => {
                      const letterEl = cell.querySelector(".cell-letter");
                      if (letterEl) letterEl.textContent = "";
                      cell.textContent = "";
                    });
                    inputCells[0].focus();
                  }, 250);
                }
              }
            }
            inputCells.forEach((cell, idx) => {
              cell.oninput = (ev) => {
                let val = cell.textContent.toUpperCase().replace(/[^A-Z]/, "");
                // Always update .cell-letter only
                const letterEl = cell.querySelector(".cell-letter");
                if (letterEl) letterEl.textContent = val;
                cell.textContent = ""; // Prevent source code or text from appearing in the cell
                // Move to next cell if input
                if (val && idx < inputCells.length - 1) {
                  inputCells[idx + 1].focus();
                }
                checkWordFilledAndValidate();
              };
              cell.onfocus = () => {
                // Place cursor at end
                const range = document.createRange();
                range.selectNodeContents(cell);
                range.collapse(false);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
              };
            });
          });
        }
      }
      grid.appendChild(cell);
    }
  }
}

function resetHints() {
  revealedCells.clear();
  hintsRemaining = hintAllowance;
  updateHintUI();
}

async function fetchClue(word) {
  try {
    const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word.toLowerCase())}`);
    if (!res.ok) throw new Error("Not found");
    const data = await res.json();
    const def = data?.[0]?.meanings?.[0]?.definitions?.[0]?.definition;
    if (def && typeof def === "string") return def;
  } catch (e) {}
  return word; // fallback to word itself
}

async function getCluesForWords(words) {
  const clueMap = {};
  await Promise.all(words.map(async w => {
    clueMap[w] = await fetchClue(w);
  }));
  return clueMap;
}

async function createNewPuzzle() {
  if (!grid) return;
  if (!words.length) {
    crosswordData = null;
    grid.innerHTML = "<div class=\"small\">No words available for this crossword.</div>";
    if (hintBtn) hintBtn.disabled = true;
    if (hintStatus) hintStatus.style.display = "none";
    return;
  }
  grid.innerHTML = '<div class="small">Loading clues and generating puzzle...</div>';
  const clueMap = await getCluesForWords(words);
  crosswordData = generateCrossword(words, gridSize);
  // Attach clues to placements
  for (const p of crosswordData.placements) {
    p.clue = clueMap[p.word] || p.word;
  }
  resetHints();
  renderClues();
  renderGrid();
}

function revealFirstLetter() {
  if (!grid || !crosswordData || hintsRemaining <= 0) return;
  const size = crosswordData.grid.length;
  const selectCellIndex = () => {
    for (const placement of crosswordData.placements || []) {
      if (placement.cells && placement.cells.length) {
        const [x, y] = placement.cells[0];
        const index = y * size + x;
        if (!revealedCells.has(index)) return index;
      }
    }
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const index = y * size + x;
        if (crosswordData.grid[y][x] !== "#" && !revealedCells.has(index)) return index;
      }
    }
    return null;
  };
  const indexToReveal = selectCellIndex();
  if (indexToReveal === null) {
    hintsRemaining = 0;
    updateHintUI();
    return;
  }
  revealedCells.add(indexToReveal);
  hintsRemaining--;
  const cell = grid.children[indexToReveal];
  if (cell) {
    const letterEl = cell.querySelector(".cell-letter");
    if (letterEl) {
      const letter = cell.dataset.letter || letterEl.textContent;
      letterEl.textContent = letter;
    }
  }
  updateHintUI();
}

updateGridClasses();
updateHintUI();
createNewPuzzle();

if (drawerToggleBtn && settingsDrawer) {
  drawerToggleBtn.addEventListener('click', () => {
    settingsDrawer.classList.toggle('open');
  });
}
if (regenBtn) {
  regenBtn.onclick = () => {
    showSolution = false;
    if (toggleBtn) toggleBtn.textContent = defaultToggleLabel;
    createNewPuzzle();
  };
}
if (printBtn) printBtn.onclick = () => window.print();
if (toggleBtn) {
  toggleBtn.onclick = () => {
    showSolution = !showSolution;
    toggleBtn.textContent = showSolution ? hideToggleLabel : defaultToggleLabel;
    renderGrid();
    updateHintUI();
  };
}
if (hintBtn) hintBtn.addEventListener("click", () => { revealFirstLetter(); });
</script>
</body>
</html>
