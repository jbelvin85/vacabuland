import { randLetter } from './app.js';
const DIRS_ALL=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]; const DIRS_NO_DIAG=[[1,0],[-1,0],[0,1],[0,-1]];
const inB=(x,y,n)=>x>=0&&y>=0&&x<n&&y<n;
function canPlace(grid,word,x,y,dx,dy){const n=grid.length; for(let i=0;i<word.length;i++){const nx=x+dx*i, ny=y+dy*i; if(!inB(nx,ny,n)) return false; const c=grid[ny][nx]; if(c!==''&&c!==word[i]) return false;} return true;}
function placeWord(grid, word, opts){const n=grid.length; const dirsBase=opts.allowDiagonals?DIRS_ALL:DIRS_NO_DIAG; const dirs=opts.allowBackwards?dirsBase:dirsBase.filter(([dx,dy])=>!(dx<0||dy<0)); const tries=n*n*dirs.length*2; for(let t=0;t<tries;t++){const [dx,dy]=dirs[Math.floor(Math.random()*dirs.length)]; const maxX=dx===1?n-word.length:dx===-1?n-1:n-1; const minX=dx===-1?word.length-1:0; const maxY=dy===1?n-word.length:dy===-1?n-1:n-1; const minY=dy===-1?word.length-1:0; const x=Math.floor(Math.random()*(maxX-minX+1))+minX; const y=Math.floor(Math.random()*(maxY-minY+1))+minY; if(canPlace(grid,word,x,y,dx,dy)){const coords=[]; for(let i=0;i<word.length;i++){const nx=x+dx*i, ny=y+dy*i; grid[ny][nx]=word[i]; coords.push([nx,ny]);} return {coords,dx,dy};}} return null;}
export function generateWordSearch(words,size,opts){const grid=Array.from({length:size},()=>Array.from({length:size},()=>'')); const normalized=words.map(w=>w.replace(/[^A-Za-z]/g,'').toUpperCase()).filter(Boolean); const sorted=Array.from(new Set(normalized)).sort((a,b)=>b.length-a.length); const placements=[]; for(const w of sorted){const use=(opts.allowBackwards&&Math.random()<0.5)?w.split('').reverse().join(''):w; const p=placeWord(grid,use,opts); if(!p){const alt=use.split('').reverse().join(''); const p2=placeWord(grid,alt,opts); if(p2){placements.push({word:w,placed:alt,coords:p2.coords});}} else {placements.push({word:w,placed:use,coords:p.coords});}} for(let y=0;y<size;y++){for(let x=0;x<size;x++){if(grid[y][x]==='') grid[y][x]=randLetter();}} return {grid,placements};}
